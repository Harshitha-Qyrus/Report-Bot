from typing import Any
from completion import Completion, FunctionCall
from db_utils.db_executor import MYSQL_ADAPTER
from promts import MYSQL_CONVERTER_PROMPT,MYSQL_CORRECTOR_PROMPT
from queries import Queries
from schemas.function_schemas import MYSQL_MODEL
import pandas as pd

class DB_SCHEMA_GENERATOR:
    def __init__(self):
        self.mysql_adapter = MYSQL_ADAPTER()
        
    # def get_all_table_names(self, database_name="webautomation"):
    #     # Fetch all table names in the specified database
    #     result = self.mysql_adapter.execute_query(Queries.get_all_table_names.format(database_name=database_name))
    #     return result
    
    # def get_table_content(self, table_name, database_name="webautomation"):
    #     # Fetch the entire content of the specified table
    #     table_data = self.mysql_adapter.execute_query(Queries.select_all_from_table.format(table_name=table_name, database_name=database_name))
    #     print("\033[45m Table: {}\033[0m\n".format(table_name))

    #     # Display the first 5 rows of the table
    #     pd.set_option('display.max_columns', None)
    #     print("First 3 rows of the table:")
    #     print(table_data.head(3))
    #     pd.reset_option('display.max_columns')

    #     # Display information about the DataFrame (column names, data types, etc.)
    #     print("\nDataFrame Info:")
    #     print(table_data.info())
    #     return table_data

                         
    def __call__(self, database_name="webautomation"):
        table_schemas = """Table schemas: \n"""
        
        
        # table_names = self.get_all_table_names(database_name)

        # # Fetch and display the content of each table
        # result = {}
        # for table_name in table_names["TABLE_NAME"]:
        #     table_content = self.get_table_content(table_name, database_name)
        #     result[table_name] = table_content

        # return result
        
        table_schema = self.mysql_adapter.execute_query(Queries.proj_schema.format(database_name=database_name))
        table_schemas += "TABLE NAME : project " + table_schema.to_csv(index=False) 
        table_schemas +="\n"+"So,in the above project table:1)project_status column indicates the status of the project (e.g., active or inactive) where the projects are filterd based on their status like \x00 which is inactive \x01 which is active. 2)organization column indicates the organization associated with the project.3)is_starred column indicates whether the project is starred or not,if \x00 then it is starred, if \x01 then it is not starred"
        
        table_schema = self.mysql_adapter.execute_query(Queries.suite_schema.format(database_name=database_name))
        table_schemas += "TABLE NAME : test_suite " + table_schema.to_csv(index=False) 
        table_schemas +="So,in the above test_suite table:1)test_suite_status columns indiactes whether the status of the suites (active or inactive)where suites are active if it is having \x01 else inactive if it has \x00."+ "\n"

        table_schema = self.mysql_adapter.execute_query(Queries.script_schema.format(database_name=database_name))
        table_schemas += "TABLE NAME : test_script " + table_schema.to_csv(index=False) + "\n"
        table_schemas +="\n"+"So,in the above test_script table:1)has_upload_data column indicates whether the data is uploaded( b'\x01') or not( b'\x00').2)is_original_script column indicates whether a particular script is considered an original version( b'\x01') or not( b'\x00') in boolean type.3)test_script_status columns refers to the status of the script (e.g., active or inactive) where the scripts are filterd based on their status,if yes b'\x01' else no then  b'\x00' 3)has_execute_test_case column is likely used to indicate whether a test case has been atleast executed( b'\x01') or not( b'\x00').4)This column is_reusable is likely used to indicate whether a specific script or test case is considered to be reusable( b'\x01') or not( b'\x00').5)column is_ai_generated refers to indicate whether a specific script has been generated by an AI( b'\x01') or not generated by AI which is manual( b'\x00')."+ "\n"

        table_schema = self.mysql_adapter.execute_query(Queries.step_schema.format(database_name=database_name))
        table_schemas += "TABLE NAME : test_step " + table_schema.to_csv(index=False) + "\n"
        table_schemas +="So,in the above test_step table:1)step_status column indicates the status of the test step where it can be filtered based on its status"

        table_schema = self.mysql_adapter.execute_query(Queries.exec_schema.format(database_name=database_name))
        table_schemas += "TABLE NAME : test_execution " + table_schema.to_csv(index=False) + "\n"
        
        table_schema = self.mysql_adapter.execute_query(Queries.sprint_schema.format(database_name=database_name))
        table_schemas += "TABLE NAME : sprint " + table_schema.to_csv(index=False) + "\n"
        
        table_schema = self.mysql_adapter.execute_query(Queries.team_schema.format(database_name="usermgmt"))
        table_schemas += "TABLE NAME : Team " + table_schema.to_csv(index=False) + "\n"
        
        table_schema = self.mysql_adapter.execute_query(Queries.team_user_schema.format(database_name="usermgmt"))
        table_schemas += "TABLE NAME : Team_user " + table_schema.to_csv(index=False) + "\n"
        
        table_schema = self.mysql_adapter.execute_query(Queries.normal_user_schema.format(database_name="usermgmt"))
        table_schemas += "TABLE NAME : Normal_user " + table_schema.to_csv(index=False) + "\n"

        db_schema = "Relations: \n"
        db_relations = self.mysql_adapter.execute_query(Queries.schema1.format(database_name=database_name))
        db_schema+= db_relations.to_csv(index=False)

        table_schemas += db_schema
        # print("\033[45m tABLE schemaaa last \033[0m",table_schemas)
        with open("tables_schema.txt","w") as fb:
            fb.write(table_schemas)
        return table_schemas

    

class SQL_CONVERTER:
    def __init__(self) -> None:
        self.function_call = FunctionCall()
        self.completion = Completion()
        print("\033[45m I am going inside mysql adapter in SQL CONVERTER \033[0m")
        self.mysql_adapter = MYSQL_ADAPTER()

    def __get_user_prompt__(self, user_description, db_schema):
        return MYSQL_CONVERTER_PROMPT.user_prompt.format(user_description=user_description, db_schema=db_schema)

        
    def __call__(self, user_description, db_schema, database_name="webautomation"):
        

        messages = [{
            "role": "system",
            "content": MYSQL_CONVERTER_PROMPT.system_prompt
        }, {
            "role": "user",
            "content": self.__get_user_prompt__(user_description, db_schema)
        }]
        
        print("\033[46m Messages in SQL CONVERTER \033[0m",messages)


        functions = [{
            "name": "execute_mysql_command",
            "description":
            """This executes mysql commands.
                """,
            "parameters": MYSQL_MODEL.schema()
        }]
        
        print("\033[45m Functions in MYSQLCONVERTER \033[0m",functions)

        _, args = self.function_call(messages=messages, model_name="gpt-4-32k", functions=functions)
        return args

class CorrectQuery:
    def __init__(self) -> None:
        self.function_call = FunctionCall()
        self.completion = Completion()
        self.mysql_adapter = MYSQL_ADAPTER()


    def __call__(self, query, error, db_schema, database_name="webautomation"):
        

        # messages = [{
        #     "content": MYSQL_CONVERTER_PROMPT.system_prompt
        # }, {
        #     "role": "user",
        #     "content": self.__get_user_prompt__(user_description)
        # }]

        # mysql_command = self.completion(messages=messages, model_name="gpt-4-32k")
        # if not mysql_command:
        #     return None
        
        
        print("CORRECTING QUERY")
        messages = [{
            "role": "system",
            "content": MYSQL_CORRECTOR_PROMPT.system_prompt
        }, {
            "role": "user",
            "content": MYSQL_CORRECTOR_PROMPT.user_prompt.format(query=query, error=error, db_schema=db_schema)
        }]


        functions = [{
            "name": "execute_mysql_command",
            "description":
            """This executes mysql commands.
                """,
            "parameters": MYSQL_MODEL.schema()
        }]

        _, args = self.function_call(messages=messages, model_name="gpt-4-32k", functions=functions)
        return args
    
if __name__=="__main__":
    db_obj=DB_SCHEMA_GENERATOR()
    db_obj()